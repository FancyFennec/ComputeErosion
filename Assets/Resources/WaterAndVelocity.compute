#pragma kernel CSMain
#include <helpers.cginc>

RWTexture2D<float4> flux;
RWTexture2D<float2> water;
RWTexture2D<float2> vel;

int resolution;
float dTime;

float computeDeltaV(uint3 id);
float2 computeVel(uint3 id, float l);

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float l = 1000.0 / ((float) resolution);
    float area = l * l; // lx * ly

    float dW = computeDeltaV(id) / area;

    water[id.xy] = float2(water[id.xy].x, water[id.xy].x + dW);
    vel[id.xy] = computeVel(id, l);
}

float computeDeltaV(uint3 id) 
{
	float fOut = flux[id.xy].x + flux[id.xy].y + flux[id.xy].z + flux[id.xy].w;
	float fIn = 0.0;
	
    if (id.x > 0)
    {
        fIn = fIn + flux[getL(id, resolution)].y;
    }
    if (id.x < resolution - 1)
    {
        fIn = fIn + flux[getR(id, resolution)].x;
    }
    if (id.y > 0)
    {
        fIn = fIn + flux[getB(id, resolution)].z;
    }
    if (id.y < resolution - 1)
    {
        fIn = fIn + flux[getT(id, resolution)].w;
    }
    
    return dTime * (fIn - fOut);
}

float2 computeVel(uint3 id, float l)
{
    float meanWater = (water[id.xy].x + water[id.xy].y) * 0.5;

    if (meanWater != 0.0) {
        float velX = (flux[getL(id, resolution)].y - flux[id.xy].x + flux[id.xy].y - flux[getR(id, resolution)].x) / (2.0 * meanWater * l);
        float velY = (flux[getB(id, resolution)].z - flux[id.xy].w + flux[id.xy].z - flux[getT(id, resolution)].w) / (2.0 * meanWater * l);
		
        return float2(velX, velY);
	}
    else {
        return float2(0.0, 0.0);
    }
}
