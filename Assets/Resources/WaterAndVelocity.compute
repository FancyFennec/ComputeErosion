#pragma kernel CSMain
#include <helpers.cginc>

RWTexture2D<float4> flux;
RWTexture2D<float> water;
RWTexture2D<float2> vel;

uint resolution;
float dTime;
float l;

float computeDeltaV(uint3 id);
float2 computeVel(uint3 id, float dWater);

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float dWater = computeDeltaV(id) / (l * l);
    vel[id.xy] = computeVel(id, dWater);
    water[id.xy] = water[id.xy] + dWater;
}

float computeDeltaV(uint3 id) 
{
	float fOut = flux[id.xy].x + flux[id.xy].y + flux[id.xy].z + flux[id.xy].w;
	float fIn = 0.0;
	
    if (id.x > 0)
    {
        fIn = fIn + flux[getL(id, resolution)].y;
    }
    if (id.x < resolution - 1)
    {
        fIn = fIn + flux[getR(id, resolution)].x;
    }
    if (id.y > 0)
    {
        fIn = fIn + flux[getB(id, resolution)].z;
    }
    if (id.y < resolution - 1)
    {
        fIn = fIn + flux[getT(id, resolution)].w;
    }
    
    return dTime * (fIn - fOut);
}

float2 computeVel(uint3 id, float dWater)
{
    float meanWater = (2 * water[id.xy] + dWater) * 0.5;

    if (meanWater > 1e-5) {
        float dWx = (flux[getL(id, resolution)].y - flux[id.xy].x + flux[id.xy].y - flux[getR(id, resolution)].x) * 0.5;
        float dWy = (flux[getB(id, resolution)].z - flux[id.xy].w + flux[id.xy].z - flux[getT(id, resolution)].w) * 0.5;
        
        return float2(dWx, dWy) / (meanWater * l);
	}
    else {
        return float2(0.0, 0.0);
    }
}
